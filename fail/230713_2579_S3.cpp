//3:45 - 4:45
#include <iostream>

using namespace std;
//n개의 계단을 오르는데 조건을 만족하면서 가장많은 점수를 얻는 계단 오르는 방법을 찾아 그 점수를 출력하라.
//연속된 3개의 계단을 밟으면 안된다. 계단 한층을 오르면 다음은 무조건 2층 -> 무조건 n-2층을 밟아야 한다. 
//i번째 계단을 밟을때 최대 점수 = (i-2번째 계단을 밟지 않고)i-1번째 계단을 밟을 때의 최대점수+A or i-2번째 계단을 밟을 떄 최대점수
//1번째 계단까지의 최대 점수 = i-1번째 계단을 밟을때, i-2번째 계단을 밟을때 
//pi = min(p(i-3)+cost(i-1),p(i-2))
// 해결 못함

//답안 풀이 : 마지막 계단을 밟았을때 이전 상황을 2가지로 나눌수 있다, n-1번째 계단을 밟았을떄 or n-1번째 계단을 밟지 않은경우
//1) n-1번째 계단을 밟았으므로 n-2번째 계단을 밟지 못한다. 2)n-1번째 계단을 밟지 않았으므로 n-2번째 게단을 밟았다.
//1) pi = p(i-3)+cost(i-1)+cost(i) 2)pi = p(i-2)+cost(i) 중 큰값? => 조건은 1칸을 3번 연속으로 밟지 말라는 조건이다 즉 점화식을 세우기 위해선
//점화식 조건을 2칸을 건널때까지로 설정해야한다. 
int n;
int cost[300];
int ans[301];
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n;

    for(int i = 0; i <n; i++){
        int x;
        cin >> x;
        cost[i] = x;
    }
    for(int i = 1; i < n; i++){
        if(i==1) ans[i] = cost[i];
        else if(i == 2) ans[i] = min(ans[i-1]+cost[i],cost[i]);
    }
    
}
