//3:53 - 4:21 포기
#include <iostream>
#include <string>
#include <stack>
//- 등장 횟수에 따라 괄호 위치가 달라진다? 
// 1) - + - => -( + ) - 2) - - + => - -( + )
// 가설 => - 부호가 등장하면 그 우항부터 다음 -부호가 등장하거나 식이 끝나면 괄호를 닫는다.
// 증명 1) - 부호가 등장했을떄 다음 -부호가 등장하기 전에 괄호를 닫는것이 더 최소다 가정
// -> a1 - (a2 + a3 ... an-1) - an+1 = 가설의 솔루션
// 1)의 가설의 솔루션으로 -> a1 - (a2 + a3 ... ak)...+an-1 - an+1가 최소가 되는 솔루션이 존재하는가? => 불가능
// 2) - 부호가 등장했을때 식이 끝날때 까지 -부호가 등장하지 않았을때 식의 끝에 괄호를 닫는것보다 더 작은 솔루션이 존재한다 가정
// a1 - (a2 + a3 ... an-1) 가설의 솔루션     2) a1 - (a2 + a3 ... +ak) ... +an-1 => 반드시 가설이 크다.


//풀이 방법 : 괄호를 계산식에 넣어 계산하면 계산 과정이 복잡해진다 -> 따라서 괄호를 모두 풀어버려 계산하도록 한다.
//가설은 동일. - 부호가 등장하면 다음의 모든 + 부호를 -부호로 바꾼다(- 부호의 분배법칙)
using namespace std;
string input;
stack<int> st; // 숫자를 저장
stack<int> mark; // 부호를 저장 0 = -  1 = +

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> input;

    int num; //숫자를 저장
    int sum = 0;
    bool in = false; //괄호 안임을 표시
    for(int i = 0; i < input.size(); i++){
        char n = input[i];
        if(n != '-' && n != '+'){ //숫자가 입력되었을때
            num = 10*num + (int)n; // 56의 경우 : 1) 5에 접근 num = 10* 0 + 5 2) 6에 접근 num = 10*5 + 6
        }
        else{
            if(n == '-'){
                if(in == false) in = true; //-부호가 2k-1 번째 발견 -> 괄호를 연다.
                else{ //-부호가 2k 번째 발견 -> 괄호를 닫는다.
                    in = false;

                }
            }
            else{ //+ 또는 
                if(in == true){ //괄호 안일 경우

                }
            }
            num = 0;
        }
    }
    


    
}