//2:06 - 2:22 3:10 - 3:18 => 24분
#include <iostream>
//n개의 집의 색을 칠하는데(색의 종류는 3개)
//1. 1번집과 2번집의 색은 다르다
//2. n번 집의 색은 n-1집의 색과 다르다.
//3. i번째 집의 색은 i-1번째,i+1번째 집의 색과 다르다.
//위의 조건을 만족하면서 주어진 색칠의 비용을 보고 가장 비용이 적게 칠하는 방법을 찾아라
//시간제한 0.5초 n <= 1000 => O(n^3)보다 작아야한다. => O(n^2)
//브루드포스 => 모든 조합을 계산 => 최악의 경우 3^1000? 안됨
//어떻게 하나... dp? :  n개의 집을 색칠하는데 드는 비용의 최소는 n-1개의 집을 색칠?
//=> 주어진 조건은 모두 연속되는 두 집의 색이 달라야하는것이다. 따라서 3개의 색에 대해 각각 다음 순서에서 선택가능한 색 중 작은 값을 선택하는것을
//반복함으로써 최솟값을 찾을수 있다.(코드상은 거꾸로 작성하긴 했지만 생각해보니 순서대로 작성해도 상관없을듯하다.) 굳이 입력값을 저장할 필요도 없다.

//답안 코드 : https://www.acmicpc.net/source/55728561
//반복적으로 선택하는것을 입력과 동시에 처리하며 while문으로 간단하게 작성하는데 이전 반복문에서 선택한 색에 따라 저장할 변수를 달리한다.
//변수는 R,G,B,r,g,b를 유지시키는데 R,G,B는 현재 선택할 색(i번째)을 의미하며. r,g,b는 i-1번째에서 각 색을 선택했을때의 1번째부터 i-1번째까지의 코스트 합의 최솟값을 의미한다.
//따라서
		// R += min(g, b); //i번째에 빨간색을 선택할경우 i-1번째에 초록색 또는 파란색을 선택한 경우의 최소값 중 작은값은 더한다.
		// G += min(r, b);
		// B += min(r, g);
		// r = R; //i번째에서 빨간색을 선택했다는 의미이며 이 값은 i+1번째에서 초록색 또는 파란색을 선택할 경우의 최소값을 찾는 과정의 후보군이 된다.
		// g = G;
		// b = B;


using namespace std;

int n;
int cost[1000][3];
int ans[1000][3];

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n;
    for(int i = 0; i < n; i++){
        int x,y,z;
        cin >> x >> y >>z;
        cost[i][0] = x;
        cost[i][1] = y;
        cost[i][2] = z;
    }

    for(int i = n-1; i >= 0; i--){
        if(i == n-1){
            ans[n-1][0] = cost[n-1][0];
            ans[n-1][1] = cost[n-1][1];
            ans[n-1][2] = cost[n-1][2];
        }else{
            ans[i][0] = cost[i][0] + min(ans[i+1][1],ans[i+1][2]);
            ans[i][1] = cost[i][1] + min(ans[i+1][0],ans[i+1][2]);
            ans[i][2] = cost[i][2] + min(ans[i+1][0],ans[i+1][1]);
        }
    }
    int num = 1000000;
    for(int i = 0; i < 3; i++){
        if(num > ans[0][i]) num = ans[0][i];
    }
    cout << num;  
}