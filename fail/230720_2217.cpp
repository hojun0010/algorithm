//2:38 - 3:20 틀렸습니다.5

//로프를 병렬적으로 연결하여 들수있는 최대 무게를 구하라
// 모든 로프를 사용하지 않아도 된다 -> 모든 로프를 사용하지 않았을때 유리한 경우가 있는가?
// 로프의 무게 한계치를 a1,a2,a3 ....an 라 하면 이 로프들을 모두 병렬 연결시켯을때 각 로프에 걸리는 무게는 k/n이다 
// 모든 로프에 대해 k/n은 무계 한계치들 중 최소값보다 작아야한다. 따라서 모든 로프를 사용하였을때 최대 무게는 min(a1,a2...an)*n 이다--1)
// 모든 로프를 사용하지 않을 경우 a1,a2,a3... aj(j < n) 이라 하면 각 로프에 걸리는 무게는 k/j 이다. min(a1,a2,a3...an 중에서 j개를 무작위 선택)*j -- 2)
// 2) > 1) 인 경우가 존재하는가? j < n 이고 2)에서 고른 최소 무게 한계치가 1)의 무게 한계치보다 클수있다.

// 2초 -> 20억 O(n^2) 보다 작아야한다.
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;
int n;
vector<int> vec;

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n;
    
    for(int i = 0; i < n ;i++){
        int x;
        cin >> x;
        //i-1번째까지의 로프를 입력받았을때의 k의 최댓값이 i번째 로프를 연결하였을때 k의 최대값보다 작아야 i번째 로프를 연결한다.
        //즉 min_num의 업데이트는 위의 상황에서 i번째 로프를 연결할때만 현재 저장된 최소 무게 한계치와 i번째 로프의 값과 비교해야한다.
        // 1번째의 로프가 없는것이 더 유리할때는 어떻게 고려해야하나? -> k = 연결한 로프들 중 무게 한계치의 최소값 * 연결한 로프의 수
        // 따라서 연결한 로프들의 무게 한계치를 최대한 큰것들을 연결하는 것이다 좋다 -> 정렬 후 큰것부터 차례대로 연결시킨다.
        vec.push_back(x);
    }
    sort(vec.begin(),vec.end(),greater<int>());
    int cnt = 0; //로프의 개수
    long long k = 0; //중량

    for(int i = 0; i < n; i++){
        int x = vec[i];
        if(k > x * (cnt+1)) break; //저장되어있는 k보다 현재의 값을 넣었을때의 k값이 작으면 break
        else{ //현재 값을 넣는것이 더 유리
            cnt++;
            k = x * cnt;//현재 값을 넣었을때의 값  
        }
    }
    cout << k;

}